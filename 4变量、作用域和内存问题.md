# 变量、作用域和内存问题

本章内容:

-   理解基本类型和引用类型的值
-   理解执行环境
-   理解垃圾收集
    javascript 的变量与其他语言的变量有很大区别。javascript 变量松散类型的本质,决定了它只是在特定时间用于保持特定值的一个名字而已。由于不存在定义某个变量必须按照要保存何种数据类型的规则,变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看,这可能是一个既有趣又强大,同事又容易出问题的特性,但 javascript 变量实际的复杂程度还远不止如此。

## 基本类型和引用类型的值

ECMAScript 变量可能包含两种不同数据类型的值:基本类性质和引用类型值。基本类型值指的是简单的数据段,而引用类型值指那些可能由多个值构成的对象。
在将一个值赋给变量时,解析器必须确定这个值是基本类性质还是引用类型值。第三章讨论了 5 中基本数据类型: Undefined,Null,Bollean,Number 和 String。这 5 种基本数据类型是按值访问的,因为可以操作保存在变量中的实际的值。
引用类型的值是保存在内存中的对象,与其他语言不用,javascript 不允许直接访问内存中的位置,也就是说不能直接操作对象的内存空间。在操作对象时,实际上是在操作对象的引用而不是实际的对象。为此,引用类型的值是按引用访问的。
**在很多语言中,字符串以对象的形式来表示,因此被认为是引用类型的。ECMASCript 放弃了这一传统。**

### 动态的属性

定义基本类性质和引用类型值的方式是类似的:创建一个变量并为该变量赋值。但是,当这个值保存到变量中后,对不同类型值可以执行的操作则大相径庭。对于引用类型的值,我们可以为其添加属性和方法,也可以改变和删除其属性和方法。
当从一个变量向另一个变量赋值引用类型的值时,同样也会将存储在变量对象中的值赋值一份方法哦新变量分配的空间中。不同的是,这个值的副本实际上是一个指针,而这个指针指向存储在堆中的一个对象。赋值操作结束后,两个变量实际上将引用同一个对象。因此,改变其中一个变量,就会影响另一个变量,如下的例子所示:

```javascript
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Nicholas";
console.log(obj2.name); // "Nicholas"
```

首先,变量 obj1 保存了一个对象的新示例。然后,这个值被赋值到了 obj2 中;换句话说,obj1 和 obj2 都指向同一个对象。这样,当为 obj1 添加 nmae 属性后,可以通过 obj2 来访问这个属性,因为这个两个变量引用的都是同一个对象。
![图4-2](/img/4/图4-2.png)

### 传递参数

ECMAScript 中所有函数的参数都是按值传递的。也就是说,把函数外部的值赋值给函数内部的参数,就和把值从一个变量赋值到另外一个变量一样。基本类型值的传递如同基本类型变量的赋值一样,而引用类型值的传递,则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑,因为访问变量有按值和按引用两种方式,而参数只能按值传递。
在向参数传递基本类型的值时,被传递的值会被复制给一个局部变量(即命名参数,或者用 ECMAScript 的概念来说,就是 arguments 对象中的一个元素)。在向参数传递引用类型的值时,会把这个值在内存中的地址复制给一个局部变量,因此这个局部变量的变化会反映在函数的外部。

```javascript
function addTen(num) {
    num += 10;
    return 10;
}
var count = 20;
var result = addTen(count);
alert(count); // 20,没有变化
alert(result); // 30
```
这里的函数addTen()有一个参数num,而参数实际上是函数的局部变量。在调用这个函数时,变量count作为参数被传递给函数,这个变量的值是20。于是,数值20被复制给参数num一边在addTen()中使用。在函数内部,参数num的值被加上了10,但这一变化不会影响函数外部的count变量。参数num与变量count互不相识,他们仅仅是具有相同的值。当然,使用数值等基本来兴来说明按置传递参数比较简单,但如果使用对象,那问题就不怎么好理解了。在举一个例子:
``` javascript
function setName(obj) {
    obj.name = "Nicholas";
}
var person = new Object();
setName(person);
console.log(person.name) // "Nicholas"
```
以上代码创建了一个对象,并将其保存在了变量person中。然后,这个变量被传递到setName()函数中之后就被复制给了obj。在这个函数内部,obj和person引用的是同一个对象。换句话说,即使这个变量是按值传递的,obj也会按引用来访问同一个对象。于是,每当在函数内部为obj添加name属性后,函数外部的person也将有所反应;因为person指向的对象在堆内存中只有一个,而且是全局对象。
**可以把ECMAScript函数的参数想象成局部变量。**
### 检测类型
要检测一个变量是不是基本数据类型,typefof操作符是最佳的工具。typeof操作符是确定一个变量是、数值、布尔值,还是undefined的最佳工具。如果变量的值是一个对象或null,则typeof操作符会想下面例子中所示的那样返回"object":
``` javascript
var s = "Nicholas";
var b = true;
var i = 22;
var u;
var n = null;
var o = new Object();
console.log(typeof s); //string
console.log(typeof i); //number
console.log(typeof b); //boolean
console.log(typeof u); //undefined
console.log(typeof n); //object
console.log(typeof o); //object
```
虽然在检测基本数据类型时typeif是非常得力的主力,但在检测引用类型的值时,这个操作符的用处不大。通常,我们并不是像知道某个值是对象,而是想知道他是什么类型的对象。为此,ECMAScript提供了instanceof操作符,如果变量是给定引用类型的(根据他的原型链来识别,详情请看第六章)实例,那么instanceof操作符就会返回true。
``` javascript
console.log(person instanceof Object);  // 变量 person 是 Object 吗？
console.log(colors instanceof Array); // 变量 colors 是 Array 吗？
console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？
```
根据规定,所有引用类型的值都是Object的实例。因此,在检测一个引用类型值和Object构造函数时,instanceof操作符时钟会返回true。当然,如果使用instanceof操作符检测基本类型的值,则该操作符时钟会返回false,因为基本来类型不是对象。
