# 数据类型
ECMAScript 中有5种简单数据类型（也被成为基本数据类型）： Undefined、Null、Boolean、Number 和 String。还有1种复杂数据类型----Object， Object 本质上是由一组无序的名值对组成的。ECMAScript 不支持任何创建自定义类型的机制，而所有值都将是上述6种数据类型之一。
## typeof 操作符
typeof 操作符可能返回系列某个字符串：
- undefined ---- 如果这个值未定义；
- boolean ---- 如果这个值是布尔值；
- string ---- 如果这个值是字符串；
- number ---- 如果这个值是数值；
- object ---- 如果这个值是对象或 **null**；
- function ---- 如果这个值是函数。
**注意：typeof 是一个操作符而不是函数,typeof(null) 会返回 Object,因为特殊值 null 被认为是一个空对象的引用。**
## undefined 类型
``` javascript
var a;
typeof(a) // undefined 
typeof(b) // undefined
console.log(a) // undefined
console.log(b) // 报错 not defined
```
对未初始化和未声明的变量执行 typeof 会返回 undefined。
### Null 类型
``` javascript
typeof(null); // Object
console.log( null == undefined ); // true 因为 "==" 会进行隐式转换。 
```
**注意: undefined 和 Null 的用途完全不同。无论什么情况下都没有必要把一个变量的值显示第设置为 undefined，可是同样的规则对 null 不适用。**换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不进可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。
## Boolean 类型
数据类型   |   转化为 true 的值   |转化为 false 的值
--|:--:|--:
Boolean   |         true        |false
String    |  任何非空字符串      |""（空字符串）
Number    |任何非零数字值（无穷大）|0和 NaN
Object    |       任何对象       |null
Undefined |        不适用       |undefined
## Number 类型
### 八进制 十进制 十六进制
除了以十进制表示外，证书还可以通过八进制或16进制的字面值来表示。其中，八进制字面的第一位必须是0，然后是八进制数字序列（0~7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当做十进制数值解析。请看下面例子：
``` javascript
var num1 = 070; // 八进制的56
var num2 = 079; // 无效的八进制数值----解析为79
var num3 = 08; // 无效的八进制数值----解析为8
```
十六进制字面的前两位必须是 0x，后跟任何十六进制数字（0~9及A~F）；其中 A ~ F 可以大写，也可以小写。
``` javascript
var num1 = 0xa; // 十六进制的 10
var num2 = 0x1f; // 十六进制的 31
```
**注意：进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。**
### 浮点数
对于极大或者及小的数值，可以用 e 表示法（即科学技术法）表示的浮点值表示。如：
``` javascript
var num1 = 3.125e7; // 等于 31250000
var num2 = 3e-7; // 等于 0.0000003
```
**0.1 + 0.2 的结果不是 0.3，因为浮点数值得最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数，这个小小的舍入误差会导致无法测试特定的浮点数值。**
### NaN
NaN，即非数值（ Not a Number ），它有两个特点：
- 任何设置 NaN 的操作（例如 NaN/10 ）都会返回 NaN;
- NaN 与任何值都不相等，包括它本身，即 NaN != NaN。
针对 NaN 这两个特点，ECMAScript 定义了 isNaN() 函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN() 在接收到一个值之后，会尝试将这个值转换为数值，某些不是数值的值会直接转换为数值，例如字符串“10”或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回true。
``` javascript
isNaN(NaN); //true
isNaN(10); // false
isNaN("10"); // false
isNaN("blue"); // true
isNaN(true); // false
isNaN({ a:1 }) // true
```
### Number()、parseInt()、parseFloat()
*推荐：由于 Number() 在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是 parseInt()。而且还会省去小数点后的数字，还能转换八进制和十六进制。*
parseInt() 接收的第二个参数是转换时使用的基数，即多少进制。
## String 类型
特点：ECMAScript 中字符串是不可变的，也就是说，字符串一旦创建，他们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后在用另一个包含新值的字符串填充该变量。
### 转换为字符串
要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法，这个方法唯一要做的就是返回相应值得字符串表现。
``` JavaScript
var age = 11;
var ageAsString = age.toString(); // 字符串 '11'
var found = true;
var foundAsString = found.toString(); // 字符串 'true'
```
数值、布尔值、对象和字符串值都有 toString() 方法。但 null 和 undefined 值没有这个方法。
在调用数值的 toString() 方法时，可以传递一个参数：输出数值的基数。
``` javascript
var num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a"
```
在不知道要转换的值是不是 null 或undefined 的情况下,还可以使用转型函数 String(),这个函数能够将任何的值转换为字符串,String() 函数遵守下列转换规则:
- 如果值有toString()方法,则调用该方法(没有参数)并返回相应的结果;
- 如果值是 null,则返回 "null";
- 如果值是 undefined,则返回 "undefined"。
``` javascript
var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1)); // "10"
alert(String(value2)); // "true"
alert(String(value3)); // "null"
alert(String(value4)); // "undefined"
```
## Object 类型
ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 **new** 操作后跟要创建的对象类型的名称来创建。而创建 Object 的实例并未其添加属性和(或)方法,就可以创建自定义对象,如下所示:
``` javascript
var o = new Object();
```
Object 的每个实例都具有下列属性和方法。
1. constructor:保存着用于创建当前对象的函数。对于前面的例子而言，构造函数 (constructor) 就是 Object()。
2. hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名 (propertypeName) 必须仪字符串形式指定（例如：o.hasOwnProperty("name")）。
3. isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型（第五章将讨论原型）。
4. propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。
5. toLocaleString()： 返回对象的字符串表示，该字符串与执行环境的地区对应。
6. toString()：返回对象的字符串表示。
7. valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。
# 操作符
包括算术操作符(如加号和减号)、位操作符、关系操作符和相等操作符。
## 一元操作符
只能操作一个值得操作符叫做一元操作符。
### 递增和递减操作符
递增和递减操作符直接借鉴自C，而且各有两个版本：前置型和后置型。
前置递增操作符：
``` javascript
var age = 29;
++age;
```
实际上,执行这个前置递增操作与执行以下操作的效果相同:
``` javascript
var age = 29;
age = age + 1;
```
执行前置递减操作符的方法也类似,结果会从一个数值减去1。使用前置递减操作符时，要把两个减号（--）放在相应变量的前面
``` javascript
var age = 29;
--age;
```
这样,age变量的值就减少为28(从29中减去了1)。
执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种情况通常被称作副效应。）请看下面这个例子。
``` javascript
var age = 29;
var anotherAge = --age + 2;
console.log(age); // 28
console.log(anotherAge); // 30
```
这个例子中变量 anotherAge 的初始值等于变量 age 的值前置递减之后加2。由于先执行了减法操作，age 的值变成了28,所以再加上2的结果就是30。
由于前置递增和递减操作与执行语句的优先级相等,因此整个语句会从左至右被求值。再看个例子
``` javascript
var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2; // 等于 21
var num4 = num1 + num2; // 等于21
```
后置递增和递减与前置递增和递减有一个非常重要的区别,即递增和递减操作是在包含他们的语句被求值之后才执行的。
``` javascript
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2; // 等于 22
var num4 = num1 + num2; // 等于 21
```
所以这4个操作符对任何值都适用,也就是他们不仅适用于整数,还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。
- 在应用于一个包含有有效数字字符的字符串时，现将其转换为数字值，在执行加减 1 的操作。字符串变量变成数值变量。
- 在应用于一个不包含有有效数字字符的字符串时，将变量的值设置为 NaN 。字符串变量变成数值变量。
- 在应用于布尔值 false 时,先将其转换为 0 在执行加减 1 的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时,执行加减 1 的操作。
- 在应用于对象时,先调用对象的 valueOf() 方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN,则在调用 toString() 方法后再应用前述规则。对象变量变成数值变量。以下实例展示了上面的一些规则:
``` javascript
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function() {
        return -1;
    }
};
s1++; // 3
s2++; // NaN
b++; // 1
f--; // 值变成 0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值 -2
```
### 一元加和减操作符
一元加操作符以一个加号(+)表示,放在数值前面,对数值不会产生影响。不过,在对非数据应用一元加操作符时,该操作符会像Number()转型函数一样对这个值执行转换。换句话说,布尔值 false 和 true 将被转换为 0 和 1,字符串值会被按照一组特殊的规则进行解析,而对象是先调用他们的 valueOf() 和 toString() 方法,再转换得到的值。
``` javascript
var s1 = '01';
var s2 = '1.1';
var s3 = 'z';
var b = false;
var f = 1.1;
var o = {
    valueOf: function(){
        return -1;
    }
};
s1 = +s1; // 1
s2 = +s2; // 1.1
s3 = + s3; // NaN
b = +b; // 0
f = +f; // 1.1
o = +o; // -1
```
一元减操作符注意用于表示负数,例如将 1 转换成 -1。下面的例子演示了这个简单的转换过程:
``` javascript
var num = 25;
num = -num; // -25
```
在应用于飞数值术,一元减操作符遵循与一元加操作符相同的规则,最后在将得到的数值转换成负数,如下面的例子所示:
``` JavaScript
var s1 = '01';
var s2 = '1.1';
var s3 = 'z';
var b = false;
var f = 1.1;
var o = {
    valueOf: function(){
        return -1;
    }
};
s1 = +s1; // -1
s2 = +s2; // -1.1
s3 = + s3; // NaN
b = +b; // 0
f = +f; // -1.1
o = +o; // 1
```
## 位操作符
### 按位非(NOT)
按位非操作符由一个波浪线(~)表示,执行按位非的结果就是返回数值的反码。
``` javascript
var num1 = 25;
var num2 = ~num1;
console.log(num2); // -26
```
### 按位与(AND)
按位与操作符由一个和号字符(&)表示,它有两个操作符数。
``` javascript
var result = 25 & 3;
console.log(result); // 1
```
### 按位或(OR)
按位或操作符由一个竖线符号(|)表示,同样也是有两个操作数。
``` javascript
var result = 25 | 3;
console.log(result);
```
### 按位异或(XOR)
按位异或操作符由一个插入符号(^)表示,有两个操作数
``` JavaScript
var result = 25 ^ 3;
console.log(result); // 26
```
### 左移操作符(<<)
左移操作符由两个小于号(<<)表示,这个操作符会将数值的所有位向左移动指定的位数,例如,如果将数值2(二进制码为10)向左移动5位,结果就是64(二进制码为1000000),代码如下所示:
``` javascript
var oldValue = 2;
var newValue = oldValue << 5;
console.log(newValue); // 64
```
### 有符号的右移(>>)
有符号的右移操作符由两个大于号(>>表示),这个操作符会将数值向右移动,但保留符号位(即正负号标记)。
### 无操作右移(>>>)
无符号右移操作符由3个大于号(>>>)表示,这个操作符会讲数值的所有32位向右移动。

## 布尔值操作符
### 逻辑非(!)
1. 如果操作符是一个空对象,返回 false;
2. 如果操作符是一个空字符串,返回 false;
3. 如果操作数是一个非空字符,返回 false;
3. 如果操作数是数值0,返回true;
4. 如果操作数是任意非 0 数值(包括 Infinity);
5. 如果操作数是 null,返回 true;
6. 如果操作数是 NaN,返回 true;
7. 如果操作数是 undefined,返回 true。
逻辑非操作符也可以用于将一个值转换为与其对应的布尔值.而同时使用两个逻辑非操作符号,实际上就会模拟 Boolean() 转型函数的行为.其中,第一个逻辑非操作会基于无论什么操作数返回一个布尔值,而第二个逻辑非操作则对该布尔值求反。于是就得到了这个值真正对应的布尔值.当然,最终结果与对这个值使用 Boolean() 函数相同。
### 逻辑与(&&)
逻辑与操作可以应用于任何类型的操作数,而不仅仅是布尔值。在有一个操作数不是布尔值的情况下,逻辑与操作就不一定返回布尔值。
1. 如果第一个操作数是对象,则返回第二个操作数;
2. 如果第二个操作数是对象,则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;
3. 如果两个操作数都是对象,则返回第二个操作数;
4. 如果第一个操作数是 NaN,则返回 NaN;
5. 如果第一个操作数是 null, 则返回 null;
6. 如果第一个操作数是 undefined,则返回 undefined。
逻辑与操作属于短路操作,技如果第一个操作数能够决定结果,那么就不会再对第二个擦偶偶书求值。对于逻辑雨操作而言,如果第一个操作数是 false,则无论第二个操作数是什么值,结果都不可能是 true。
例子1:
``` JavaScript
var found = ture;
var result = (found && someUndefinedVariable); // 这里会报错
console.log(result); // 这一行不会执行
```
例子2:
``` JavaScript
var found = false;
var result = (found && someUndefinedVariable); // 不会报错
console.log(result); // false
```

## 乘性操作
### 乘法(*)
1. 如果是 Infinity 与 0 相乘,则结果是NaN;
2. 如果是 Infinity 与非 0 数值相乘,则结果是 Infinity 或 -Infinity,取决于有符号操作数的符号;
3. 如果有一个操作数不是数值,则在后台调用 Number() 将其转换为数值,然后再应用以上规则。
### 除法(/)
### 求模(%)

## 加性操作符
### 加法(+)
### 减法(-)
## 关系操作符
小于(<)、大于(>)、小于等于(<>=)和大于等于(>=)这个几个关系操作符用于对两个值进行比较。
1. 如果两个操作数都是数值，则执行数值比较；
2. 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值；
3. 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较;
4. 如果一个操作数是对象，则调用这个对象的 valueOf() 方法,用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法,则调用 toString(),并用得到的结果根据前面的规则执行比较;
5. 如果一个操作数是布尔值,则先将其转换为数值,然后在执行比较。
**在比较字符串值时,实际比较的是两个字符串中对应位置的每个字符的字符编码值。经过着么一饭比较滞后,再返回一个布尔值。由于大写字母的字符编码全部小于小写字符的字符编码,因此会看到以下现象:**
``` JavaScript
var result = "Brick" < "alphabet"; // true
```
另一种奇怪的现象发生在比较两个数字字符串的情况下:
``` JavaScript
var result = "23" < "3"; // true
```
结果居然是 true,这是因为两个操作数都是字符串,而字符串比较的是字符编码("2"的字符串编码是50,而"3"的祖父穿编码是51)。不过,像下面例子一样,将一个操作数改成数值,比较的结果就正常了。
``` JavaScript
var result = '23' < 3; // false
```
此时,字符串'23'会转换成数值23,然后再与3进行比较,因此就会的得到合理的结果。在比较数值和字符串时,字符串都会被转换成数值,然后再以数值方式与另一个数值比较,当然,这个规则对前面的例子是使用的。但如果那个字符串不能被转换成一个合理的数值呢?比如:
``` JavaScript
var result = "a" < 3; // false,因为"a"被转换成了NaN
var result1 = NaN < 3; // false
var result2 = NaN >= 3; // flase
```
由于字幕"a"不能转换成合理的数值,因此就被转换成了NaN。根据规则,任何操作数与NaN进行关系比较,结果都是 false。于是,就出现了下面这个有意思的现象:
